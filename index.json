[{"body":"","link":"https://vuduynhien.com/","section":"","tags":null,"title":""},{"body":"","link":"https://vuduynhien.com/post/backend/","section":"post","tags":null,"title":""},{"body":"","link":"https://vuduynhien.com/series/backend/","section":"series","tags":null,"title":"backend"},{"body":"","link":"https://vuduynhien.com/tags/express/","section":"tags","tags":null,"title":"express"},{"body":"HANDLEBAR LÀ GÌ ?  handlebars là một ngôn ngữ template đơn giản dễ dùng. nó sử dụng một template và một object đầu vào để generate ra HTML hoặc các loại định dạng text khác. Handlebars template trông giống như text bình thường nhưng có thể nhúng các giá trị vào thông qua biểu thức. như ví dụ sau: {{firstname}} {{lastname}}\n một biểu thức handlebar trông giống như này {{  nội dung  }} khi một template được biên dịch, những biểu thức này sẽ được thay thế bằng các giá trị từ object đầu vào.\nCÀI ĐẶT \n load từ CDN và nhúng nó vào trong HTML file cài đặt từ npm   TÍNH NĂNG CỦA HANDLEBARS\n Biểu thức đơn giản dễ dùng Nhìn vào ví dụ sau là hiểu  {{firstname}} {{lastname}}\n các biến firstname, lastname được lấy từ object\n { firstname: \"Yehuda\", lastname: \"Katz\", }  Biểu thức sẽ thay thế các biến bởi các thuộc tính tương ứng, kết quả sẽ như sau\n  Yehua Katz  Đôi lúc, object đầu vào chứa một object khác (nested object) hoặc một array. Ví dụ\n { person: { firstname: \"Yehuda\", lastname: \"Katz\", }, }  Trong trường hợp này bạn có thể sử dụng dấu . để truy cập được vào các thuộc tính bên trong object\n {{person.firstname}} {{person.lastname}}  Một vài built-in sẽ cho phép bạn truy cập các thuộc tính của object mà không phải tìm ra object cha rồi dùng dấu . để truy cập vào từng thuộc tính. Ví dự như: Built-in  each  và  with \nwith sẽ lùng sục tất cả các thuộc tính của object và cho phép bạn truy cập vào các thuộc tính của nó một cách đơn giản như này\n {{#with person}} {{firstname}} {{lastname}} {{/with}}   { person: { firstname: \"Yehuda\", lastname: \"Katz\", }, }  each sẽ lặp như cách một mảng lặp, cho phép bạn truy cập tới thuộc tính của từng đối tượng thông qua một biểu thức handlebars đơn giản như sau\n {{#each people}} {{this}} {{/each}}    { people: [ \"Yehuda Katz\", \"Alan Johnson\", \"Charles Jolley\", ]. }   COMMENT TRONG TEMPLATE HANDLEBARS \nBạn có thể sử dụng comment trong handlebars qua các cách sau\n {{! Comment này sẽ không xuất ra khi render ra HTML }} {{!-- Comment này có thể chứa các kí tự đặc biệt như }} --}}  CUSTOM CÁC TIỆN TÍCH HỖ TRỢ CHO HANDLEBARS Handlebars có thể được truy cập từ bất kì context nào trong 1 template. Bạn có thể đăng kí một tiện tích hỗ trợ với hàm Handlebars.registerHelper {{firstname}} {{lound lastname}}\nHandlebars.registerHelper('lound', function (aString) { return aString.toUpperCase() })\nCác tiện tích hỗ trợ sẽ nhận các giá trị từ this của function {{#each people}} {{print_person}} {{/each}}\nHandlebars.registerHelper('print_person', function () { return this.firstname + ' ' + this.lastname })\nCÁC KHỐI TIỆN ÍCH HỖ TRỢ Khối tiện ích hỗ trợ (block helprs) sẽ cho phép bạn tạo ra các template mà bạn tùy chỉnh theo ý của bạn, ví dự bạn có một object sau\n{ people: [ { firstname: \u0026quot;Yehuda\u0026quot;, lastname: \u0026quot;Katz\u0026quot;, }, { firstname: \u0026quot;Carl\u0026quot;, lastname: \u0026quot;Lerche\u0026quot;, }, { firstname: \u0026quot;Alan\u0026quot;, lastname: \u0026quot;Johnson\u0026quot;, }, ], }\nbạn muốn tạo ra 1 template mà kết quả sau khi render sẽ bao gồm firstname + lastname  Yehuda Katz thì làm như sau: Handlebars.registerHelper(\u0026quot;list\u0026quot;, function (items, options) { const itemsAsHtml = items.map(item =\u0026gt; \u0026quot;\u0026quot; + options.fn(item) + \u0026quot;\u0026quot;); return \u0026quot;\\n\u0026quot; + itemsAsHtml.join(\u0026quot;\\n\u0026quot;) + \u0026quot;\\n\u0026quot;; });\nví dụ trên tạo ra một tiện ích hỗ trợ tên là list để generate ra một mẫu HTML list. Tiện ích hỗ trợ nhận vào tham số đầu tiên là people, và tham số thứ hay là options. Option chứa thuộc tính fn, thuộc tính fn có thể gọi tới một context Khi được biên dịch, templte sẽ render ra kết quả\n Yehuda Katz Carl Lerche Alan Johnson  Các khối tiện ích hỗ trợ có nhiều tính năng hơn, vào trang handlebars để đọc. example for blockhelpers\nHTML ESCAPING Vì hanlebars được thiết kế để generate ra mã HTML thế nên với một số kí tự đặc biệt, nếu muốn dữ nguyên hình của nó thì đọc hiểu đoạn code bên với\nVới object { specialChars: \u0026quot;\u0026amp; \u0026lt; \u0026gt; \u0026quot; ' ` =\u0026quot; }\nmà chạy trong template raw: {{{specialChars}}} html-escaped: {{specialChars}}\nKết quả sẽ là raw: \u0026amp; \u0026lt; \u0026gt; \u0026quot; ' ` = html-escaped: \u0026amp; \u0026lt; \u0026gt; \u0026quot; ' ` =\nĐọc thêm về safe string thông qua ví dụ PARTIALS handlebars cho phép code được tái sử dụng bằng cách tạo ra template rồi chia sẻ nó với các component khác. Đăng kí template tái sử dụng bằng cách sử dụng phương thức registerPartial xem qua ví dụ sau\nMỘT SỐ HÀM BUILT-IN HỖ TRỢ CHO HANDLEBARS #if có thể sử dụng if để tạo ra một vế render điều kiện. Nếu tham số trả về false, undefined, null, \u0026quot;\u0026quot;, 0 hoặc [] handlebars sẽ không render ra khối template. click để xem ví dụ một cách trực quan\n.... đọc thêm ở đây\n","link":"https://vuduynhien.com/post/backend/posts/handlebars/","section":"post","tags":["template engnine","express","lập trình web"],"title":"handlebar có ngu không, nếu không ngu vậy khôn ở chỗ nào ?"},{"body":"","link":"https://vuduynhien.com/tags/l%E1%BA%ADp-tr%C3%ACnh-web/","section":"tags","tags":null,"title":"lập trình web"},{"body":"","link":"https://vuduynhien.com/post/","section":"post","tags":null,"title":"Posts"},{"body":"","link":"https://vuduynhien.com/series/","section":"series","tags":null,"title":"Series"},{"body":"","link":"https://vuduynhien.com/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://vuduynhien.com/tags/template-engnine/","section":"tags","tags":null,"title":"template engnine"},{"body":"","link":"https://vuduynhien.com/tags/database/","section":"tags","tags":null,"title":"database"},{"body":"Redis command line interfce (redis-cli) hay c\u0026ograve;n gọi l\u0026agrave; giao diện d\u0026ograve;ng lệnh của redis l\u0026agrave; một chương tr\u0026igrave;nh dạng terminal được d\u0026ugrave;ng để gửi c\u0026aacute;c lệnh l\u0026ecirc;n server redis v\u0026agrave; server redis sẽ phản hồi lại c\u0026aacute;c lệnh do người d\u0026ugrave;ng gửi l\u0026ecirc;n. Redis-cli Bao gồm 2 chế độ ch\u0026iacute;nh:\n tương t\u0026aacute;c Read Evel Print Loop (REPL), REPL l\u0026agrave; nơi người d\u0026ugrave;ng nhập c\u0026aacute;c lệnh v\u0026agrave; nhận về c\u0026aacute;c phản hồi.\u0026nbsp; một chế độ d\u0026ograve;ng lệnh nơi redis-cli được bi\u0026ecirc;n dịch với c\u0026aacute;c tham số bổ sung v\u0026agrave; phản hồi sẽ được in ra theo ti\u0026ecirc;u chuẩn  RedisInsight l\u0026agrave; một c\u0026ocirc;ng cụ kết hợp GUI với CLI gi\u0026uacute;p bạn l\u0026agrave;m việc với bất k\u0026igrave; dự \u0026aacute;n n\u0026agrave;o cần triển khai với redis. Bạn c\u0026oacute; thể duyệt v\u0026agrave; tương t\u0026aacute;c với data một c\u0026aacute;ch trực quan, hay tận dụng c\u0026aacute;c c\u0026ocirc;ng cụ n\u0026acirc;ng cao như c\u0026aacute;c c\u0026ocirc;ng cụ chẩn đo\u0026aacute;n, RedisInsight\u0026nbsp;miễn ph\u0026iacute;\u0026nbsp;nha.\u0026nbsp;\n\nRedis CLI\u0026nbsp;\n\nTổng quan về redis-cli\nỞ trong chế độ tương t\u0026aacute;c, redis-cli c\u0026oacute; khả năng chỉnh sửa d\u0026ograve;ng cơ bản để mang lại trải nghiệm g\u0026otilde; th\u0026acirc;n thiện.\n\nĐể mở chương tr\u0026igrave;nh trong chế độ đặc biệt, bạn c\u0026oacute; thể sử dụng c\u0026aacute;c option, bao gồm:\n M\u0026ocirc; phỏng một bản sao v\u0026agrave; in luồng bản sao m\u0026agrave; n\u0026oacute; nhận từ bản ch\u0026iacute;nh Kiểm tra độ trễ của m\u0026aacute;y chủ Redis v\u0026agrave; hiển thị số liệu thống k\u0026ecirc; Y\u0026ecirc;u cầu biểu đồ phổ nghệ thuật ASCII của c\u0026aacute;c mẫu v\u0026agrave; tần số độ trễ  Chủ đề n\u0026agrave;y bao qu\u0026aacute;t c\u0026aacute;c kh\u0026iacute;a cạnh kh\u0026aacute;c nhau của redis-cli. bắt đầu từ những thứ đơn giản nhất v\u0026agrave; kết th\u0026uacute;c bằng c\u0026aacute;c t\u0026iacute;nh năng n\u0026acirc;ng cao.\u0026nbsp;\nSỬ DỤNG COMMAND LINE\nĐể chạy c\u0026aacute;c lệnh redis v\u0026agrave; trả về c\u0026aacute;c output ti\u0026ecirc;u chuẩn ở terminal, bao gồm c\u0026aacute;c lệnh để thực thu dưới dạng c\u0026aacute;c đối số ri\u0026ecirc;ng biệt của redis-cli\n$ redis-cli INCR mycounter\n(interger) 7\nkết quả của phản hồi được in ra l\u0026agrave; \u0026quot;7\u0026quot;. Khi nhận c\u0026aacute;c phản hồi từ redis (strings, arrays, integers, nil, errors, etc..) bạn sẽ thấy được c\u0026aacute;c loại của phản hồi giữa c\u0026aacute;c dấu ngoặc đơn. Th\u0026ocirc;ng tin n\u0026agrave;y c\u0026oacute; thể kh\u0026ocirc;ng c\u0026ograve;n l\u0026iacute; tưởng khi đầu ra của redis-cli được sử dụng l\u0026agrave;m đầu v\u0026agrave;o của một lệnh kh\u0026aacute;c hoặc được chuyển hướng v\u0026agrave;o một tệp.\nRedis-cli chỉ show ra c\u0026aacute;c th\u0026ocirc;ng tin bổ sung gi\u0026uacute;p trực quan với người d\u0026ugrave;ng hơn khi n\u0026oacute; t\u0026igrave;m thấy c\u0026aacute;c ti\u0026ecirc;u chuẩn đầu ra như một tty hoặc terminal. Tất cả c\u0026aacute;c đầu ra kh\u0026aacute;c sẽ tự động k\u0026iacute;ch hoạt chế độ output th\u0026ocirc;, như v\u0026iacute; dụ dưới\n$ redis-cli INCR mycounter \u0026gt; /tmp/output.txt\n$ cat /tmp/output.txt\n8\nLưu \u0026yacute; rằng (integer) sẽ bị bỏ qua khỏi đầu ra bởi redis-cli nhận thấy output kh\u0026ocirc;ng được viết ở terminal, bạn c\u0026oacute; thể th\u0026ecirc;m --raw để hiển thị output th\u0026ocirc;.\n$ redis-cli --raw INCR mycounter\n9\nsử dụng\u0026nbsp;--no-raw\u0026nbsp; để tr\u0026ocirc;ng human readable hơn\nCHUỖI TR\u0026Iacute;CH DẪN V\u0026Agrave; THO\u0026Aacute;T \u0026nbsp;\nKhi redis-cli parses a command, khoảng trắng sẽ được tự động d\u0026ugrave;ng để chia c\u0026aacute;ch giữa c\u0026aacute;c tham số. Trong chế độ tương t\u0026aacute;c, một d\u0026ograve;ng gửi lệnh cho việc ph\u0026acirc;n t\u0026iacute;ch c\u0026uacute; ph\u0026aacute;p v\u0026agrave; thực thi. Để nhập gi\u0026aacute; trị đầu v\u0026agrave;o bao gồm khoảng trắng hoặc chứa c\u0026aacute;c k\u0026iacute; tự kh\u0026ocirc;ng thể in ra được, bạn h\u0026atilde;y sử dụng quoted v\u0026agrave; escaped strings.\nGi\u0026aacute; trị chuỗi quoted được nằm trong 2 dấu \u0026quot; \u0026quot; hoặc một \u0026nbsp;dấu \u0026apos;. \u0026nbsp;Escape sequence được sử dụng để đặt c\u0026aacute;c k\u0026iacute; tự kh\u0026ocirc;ng in ra được trong k\u0026yacute; tự v\u0026agrave; chuỗi k\u0026iacute; tự.\nMột escape sequence chứa một backslash (\\) theo sau l\u0026agrave; một k\u0026iacute; tự escape sequence.\nhỗ trợ c\u0026aacute;c escape sequenes sau:\u0026nbsp;\n\u0026nbsp;\n \\n - double -quote \\n - new line \\r - carriage return \\b - backspace \\a - alert \\\\ - backslash \\xhh - bất k\u0026igrave; k\u0026iacute; tự ASCII đại diện bởi một số thập lục ph\u0026acirc;n (hh)  v\u0026iacute; dụ, để trả về Hello World trong 2 d\u0026ograve;ng; \u0026nbsp; 127.0.0.1:6379\u0026gt; SET mykey \u0026quot;Hello\\nWorld\u0026quot; OK 127.0.0.1:6379\u0026gt; GET mykey Hello\u0026nbsp;\nWorld \u0026nbsp; Khi bạn nhập một chuỗi chứa một họăc hai quotes, như password, v\u0026iacute; dụ \u0026nbsp; 127.0.0.1:6379\u0026gt; AUTH some_admin_user \u0026quot;\u0026gt;^8T\u0026gt;6Na{u|jp\u0026gt;\u0026quot;55\\@;OU(OR]7mbAYGqsfyu48(j\u0026apos;%hQH7;v*f1H$*D(Se\u0026apos;\u0026quot;\u0026apos; \u0026nbsp; M\u0026aacute;y chủ, cổng, mật khẩu, v\u0026agrave; cơ sở dữ liệu \u0026nbsp; Mặc định redis-cli sẽ kết nối tới server tại địa chỉ\u0026nbsp;127.0.0.1 với port\u0026nbsp;6379.\u0026nbsp;Bạn c\u0026oacute; thể thay đổi port bằng c\u0026aacute;ch sử dụng c\u0026aacute;c options. Để chỉ định một host kh\u0026aacute;c hoặc một địa chỉ IP, sử dụng -h. Để set c\u0026aacute;c port kh\u0026aacute;c sử dụng -p \u0026nbsp; $ redis-cli -h redis15.localnet.org -p 6379 PING PONG \nNếu phi\u0026ecirc;n bản của bạn được bảo vệ bằng mật khẩu, d\u0026ugrave;ng -a \u0026lt;password\u0026gt; để x\u0026aacute;c thực\u0026nbsp; \u0026nbsp; $ redis-cli -a myUnguessablePazzzword1234 PING PONG \u0026nbsp; Lưu \u0026yacute;: v\u0026igrave; l\u0026iacute; do bảo mật, h\u0026atilde;y gửi mật khẩu đến redis-cli th\u0026ocirc;ng qua biến m\u0026ocirc;i trường REDISCLI_AUTH \u0026nbsp;\nCuối c\u0026ugrave;ng, \u0026nbsp;c\u0026oacute; thể gửi command tr\u0026ecirc;n một số cơ sở dữ liệu kh\u0026aacute;c nhau với số 0 mặc định bằng c\u0026aacute;ch sử dụng t\u0026ugrave;y chọn -n \u0026lt;dbnum\u0026gt;\n$ redis-cli FLUSHALL\nOK\n$ redis-cli -n 1 INCR a\n(integer) 1\n$ redis-cli -n 1 INCR a\n(integer) 2\n$ redis-cli -n 2 INCR a\n(integer) 1\nmột số hoặc tất cả th\u0026ocirc;ng tin n\u0026agrave;y cũng c\u0026oacute; thể được cung cấp bằng c\u0026aacute;ch sử dụng -u \u0026lt;uri\u0026gt; v\u0026agrave; mẫu URI redis://user:password@host:port/dbnum\n$ redis-cli -u redis://LJenkins:p%40ssw0rd@redis-16379.hosted.com:16379/0 PING\nPONG\nSSL/TLS\nMặc định redis-cli sử dụng kết nối TCP để kết nối tới Redis. Bạn c\u0026oacute; thể k\u0026iacute;ch hoạt SSL/TLS bằng c\u0026aacute;ch sử dụng --tls, với --carcert hoặc --cacertdir để cấu h\u0026igrave;nh g\u0026oacute;i hoặc thư mục chứng chỉ gốc đ\u0026aacute;ng tin cậy\nNếu server y\u0026ecirc;u cầu x\u0026aacute;c thực bằng c\u0026aacute;ch sử dụng chứng chỉ b\u0026ecirc;n client, bạn c\u0026oacute; thể chỉ định một chứng chỉ v\u0026agrave; một privateky sử dụng --cert v\u0026agrave; --key\nLẤY ĐẦU V\u0026Agrave;O TỪ C\u0026Aacute;C CHƯƠNG TR\u0026Igrave;NH KH\u0026Aacute;C\nC\u0026oacute; 2 c\u0026aacute;ch bạn c\u0026oacute; thể sử dụng redis-cli để nhận đầu v\u0026agrave;o từ c\u0026aacute;c lệnh th\u0026ocirc;ng qua ti\u0026ecirc;u chuẩn đầu ra. Một l\u0026agrave; sử dụng payload như l\u0026agrave; phần cuối đối số stdin. V\u0026iacute; dụ, để set Redis key net_services tới nội dung trong file /etc/services từ hệ thống file local, sử dụng -x option\n$ redis-cli -x SET net_services \u0026lt; /etc/services\nOK\n$ redis-cli GETRANGE net_services 0 50\n\u0026quot;#\\n# Network services, Internet style\\n#\\n# Note that \u0026quot;\ntrong d\u0026ograve;ng đầu ti\u0026ecirc;n, redis-cli được bi\u0026ecirc;n dịch với\u0026nbsp;-x\u0026nbsp;v\u0026agrave; một file sẽ được chuyển hướng đến ti\u0026ecirc;u chuẩn đầu v\u0026agrave;o CLI như một gi\u0026aacute; trị dể đ\u0026aacute;p ứng cụm lệnh net_services . Điều n\u0026agrave;y hữu \u0026iacute;ch cho việc code c\u0026aacute;c \u0026nbsp;kịch bản\u0026nbsp;\n\u0026nbsp;\nhttps://redis.io/docs/ui/cli/\n\u0026nbsp;\nA different approach is to feed redis-cli a sequence of commands written in a text file: $ cat /tmp/commands.txt SET item:3374 100 INCR item:3374 APPEND item:3374 xxx GET item:3374 $ cat /tmp/commands.txt | redis-cli OK (integer) 101 (integer) 6 \u0026quot;101xxx\u0026quot;  All the commands in commands.txt are executed consecutively by redis-cli as if they were typed by the user in interactive mode. Strings can be quoted inside the file if needed, so that it\u0026apos;s possible to have single arguments with spaces, newlines, or other special characters: $ cat /tmp/commands.txt SET arg_example \u0026quot;This is a single argument\u0026quot; STRLEN arg_example $ cat /tmp/commands.txt | redis-cli OK (integer) 25  Continuously run the same command \u0026nbsp;\n\u0026nbsp;\n","link":"https://vuduynhien.com/post/backend/posts/huong-dan-ve-redis/","section":"post","tags":["database","lập trình web","redis"],"title":"Hướng dẫn về redis"},{"body":"","link":"https://vuduynhien.com/tags/redis/","section":"tags","tags":null,"title":"redis"},{"body":"","link":"https://vuduynhien.com/tags/authorization/","section":"tags","tags":null,"title":"authorization"},{"body":"JWT (JSON Web Token) là một bộ tiêu chuẩn mở (RFC 7519) nhỏ gọn và có tính đóng gói, được sử dụng cho việc truyền thông tin (các thông tin dưới dạng JSON object ) một cách an toàn giữa các bên. Thông tin sẽ được xác minh và có tính tin cậy bởi vì nó có chứa chữ kí kĩ thuật sử dụng một secret (với thuật toán HMAC ) hoặc một cặp public/private key dùng RSA hoặc ECDSA.\nMặc dù JWTs có thể được mã hóa để cung cấp sự bảo mật giữa các bên, nhưng chúng ta chỉ tập trung vào token đã được kí (token này sinh ra sau khi có các thông tin chứng thực) . Token đã được kí có thể xác minh được các thông tin chứng thực có trong nó, trong khi đó token được mã hóa lại ẩn những thông tin chứng thực này cho các bên khác. Khi token đã kí sử dụng public/private key, chữ kí có thể đc xác mình rằng chỉ bên nắm giữ private key mới được kí nó\nTại sao chúng ta nên sử dụng JSON Web Tokens ?\nsau đây là một vài trường hợp phát huy được sự hữu dụng của JSON Web Tokens:\n Authorizations: đ\u0026acirc;y l\u0026agrave; trường hợp phổ biến nhất cho việc sử dụng JWT. Khi user đăng nhập v\u0026agrave;o hệ thống, Mỗi request tiếp theo sau đ\u0026oacute; sẽ được đ\u0026iacute;nh k\u0026egrave;m JWT,\u0026nbsp; token n\u0026agrave;y sẽ cho ph\u0026eacute;p user c\u0026oacute; quyền truy cập v\u0026agrave;o routes, services, v\u0026agrave; c\u0026aacute;c t\u0026agrave;i nguy\u0026ecirc;n,... m\u0026agrave; token đ\u0026oacute; c\u0026oacute; thẩm quyền truy cập. Trao đổi th\u0026ocirc;ng tin: sử dụng JSON Web Tokens trong trường hợp trao đổi th\u0026ocirc;ng tin bảo mật giữa c\u0026aacute;c b\u0026ecirc;n. Bởi v\u0026igrave;\u0026nbsp; JWTs được k\u0026iacute;\u0026nbsp; bạn c\u0026oacute; thể chắc chắn rằng người gửi l\u0026agrave; ai, nội dung th\u0026ocirc;ng tin kh\u0026ocirc;ng bị giả mạo bởi chữ k\u0026iacute; được t\u0026iacute;nh to\u0026aacute;n, sử dụng bởi header v\u0026agrave; and payload   Cấu tr\u0026uacute;c của JSON Web Token ?\nJSON Web Tokens bao gồm 3 phần được ngăn cách nhau bởi dấu . (chấm) là:\n header payload signature  do đ\u0026oacute;, một JWT thường tr\u0026ocirc;ng như sau:\nxxxx.yyyyy.zzzzz\n\nHeader\nthường chứa 2 phần: kiểu của token v\u0026agrave; thuật to\u0026aacute;n d\u0026ugrave;ng để k\u0026iacute; n\u0026agrave;o được sử dụng (HMAC SHA2556 hay RSA)\nv\u0026iacute; dụ\u0026nbsp;\n{\n\u0026nbsp; \u0026nbsp; \"alg\": \"HS256\",\n\u0026nbsp; \u0026nbsp; \"typ\": \"JWT\"\n}\nđ\u0026acirc;y l\u0026agrave; JSON m\u0026atilde; h\u0026oacute;a Base64Url. Th\u0026agrave;nh phần đầu ti\u0026ecirc;n của JWT.\nPayload\nPhần thứ 2 của token l\u0026agrave; payload, chứa phần chứng thực, chứng thực l\u0026agrave; th\u0026agrave;nh phần về một thực thể (thường l\u0026agrave; user) hoặc c\u0026aacute;c th\u0026ocirc;ng tin bổ sung. Đ\u0026acirc;y l\u0026agrave; 3 kiểu chứng chứng: registered, public, private\u0026nbsp;\n registered claims: đ\u0026acirc;y l\u0026agrave; một x\u0026aacute;c nhận quyền sử hữu, kh\u0026ocirc;ng bắt buộc nhưng được khuyến nghị để cung cấp tập hợp c\u0026aacute;c x\u0026aacute;c thực hữu \u0026iacute;ch, c\u0026oacute; thể tương t\u0026aacute;c với nhau. Một số trong đ\u0026oacute; l\u0026agrave;: iss(isuser), exp (thời gian hết hạn), sub (chủ đề), aud (audience) v\u0026agrave; những thứ kh\u0026aacute;c nữa. public claims: người sử dụng JWTs c\u0026oacute; thể định nghĩa\u0026nbsp; phần n\u0026agrave;y t\u0026ugrave;y \u0026yacute;. Nhưng để tr\u0026aacute;nh xung đột,\u0026nbsp; phần n\u0026agrave;y n\u0026ecirc;n được x\u0026aacute;c định trong IANA JSON Web Token Registry hoặc được x\u0026aacute;c định l\u0026agrave; một URI tr\u0026aacute;nh xung đột private claims: đ\u0026acirc;y l\u0026agrave; một chứng thực t\u0026ugrave;y chỉnh được tạo để chia sẻ th\u0026ocirc;ng tin giữa c\u0026aacute;c b\u0026ecirc;n được đồng \u0026yacute; sử dụng ch\u0026uacute;ng v\u0026agrave; c\u0026aacute;c b\u0026ecirc;n c\u0026aacute;c đăng k\u0026iacute; kh\u0026aacute;c hoặc public claims  một v\u0026iacute; dụ về payload:\n{\n\u0026nbsp; \u0026nbsp; \"sub\": \"1234567890\",\n\u0026nbsp; \u0026nbsp; \"name\": \"John Doe\",\n\u0026nbsp; \u0026nbsp; \"admin\": true\n}\npayload được m\u0026atilde; h\u0026oacute;a bởi Base64UrI, đ\u0026acirc;y l\u0026agrave; phần thứ 2 của JSON Web Token\nsingature\nđể tạo phần signature, bạn cần phải lấy header, payload đ\u0026atilde; được m\u0026atilde; h\u0026oacute;a, một secret, thuật to\u0026aacute;n được sử dụng chỉ định trong header v\u0026agrave; k\u0026iacute; n\u0026oacute;.\u0026nbsp;\nV\u0026iacute; dụ bạn muốn sử dụng thuật to\u0026aacute;n HMAC SHA256, chữ k\u0026iacute; sẽ dược tạo như sau\nHMACSHA256(\n\u0026nbsp; \u0026nbsp; base64UrlEncode(header) + \".\" +\n\u0026nbsp; \u0026nbsp; base64UrIEncode(payload),\n\u0026nbsp; \u0026nbsp; secret\n)\nchữ k\u0026iacute; được sử dụng để x\u0026aacute;c thực th\u0026ocirc;ng điệp kh\u0026ocirc;ng được thay đổi, v\u0026agrave; trong trường hợp token được k\u0026iacute; với một private key, n\u0026oacute; c\u0026oacute; thể được x\u0026aacute;c minh người gửi của JWT rằng người đ\u0026oacute; l\u0026agrave; ai\nPutting all together\n output l\u0026agrave; một chuỗi string m\u0026atilde; h\u0026oacute;a bằng Base64URL được phần t\u0026aacute;ch c\u0026aacute;c th\u0026agrave;nh phần bằng dấu chấm, c\u0026oacute; thể được dễ d\u0026agrave;ng truyền trong HTML hoặc m\u0026ocirc;i trường HTTP, nhỏ gọn hơn khi so với với c\u0026aacute;ch chuẩn dựa tr\u0026ecirc;n XML như SAML\nJSON Web Token hoạt động như thế n\u0026agrave;o ?\nkhi người d\u0026ugrave;ng th\u0026agrave;nh c\u0026ocirc;ng đăng nhập sử dụng c\u0026aacute;c th\u0026ocirc;ng tin x\u0026aacute;c thực, một JSON Web Token sẽ được sinh ra.\u0026nbsp; Token d\u0026ugrave;ng để thay thế việc x\u0026aacute;c thực, do vậy h\u0026atilde;y cần thận với token để ngăn chặn c\u0026aacute;c vấn đề bảo mật. Token kh\u0026ocirc;ng n\u0026ecirc;n được sống qu\u0026aacute; l\u0026acirc;u so với y\u0026ecirc;u cầu.\nMỗi khi user muốn truy cập v\u0026agrave;o một route hoặc một t\u0026agrave;i nguy\u0026ecirc;n, user sẽ gửi JWT, thường trong phần Authoiation sử dụng Bearer schema. N\u0026ocirc;i dung của header sẽ tr\u0026ocirc;ng nhwu sau:\nAuthorization: Bearer \u0026lt;token\u0026gt;\nNếu bạn gửi tokens JTW th\u0026ocirc;ng qua HTTP headers, bạn n\u0026ecirc;n tr\u0026aacute;nh gửi n\u0026oacute; khi m\u0026agrave; dung lượng qu\u0026aacute; lớn. Một v\u0026agrave;i server kh\u0026ocirc;ng chấp nhận nhiều hơn 8KB ở trong headers. Nếu bạn cố gắng nh\u0026uacute;ng qu\u0026aacute; nhiều th\u0026ocirc;ng tin v\u0026agrave;o trong 1 JWT token, như bao gồm cả quyền hạn của usẻ, bạn c\u0026oacute; thể cần một giải ph\u0026aacute;p kh\u0026aacute;c, vd như Auth0 Fine-Grained Authorization\nnếu token được gửi v\u0026agrave;o trong Authorizatoin header, Cross-Origin Resource Sharing (CORS) sẽ kh\u0026ocirc;ng gặp lỗi v\u0026igrave; n\u0026oacute; kh\u0026ocirc;ng sử dụng cookie\nBiểu đồ dưới đ\u0026acirc;y minh họa JWT được nhận như thế n\u0026agrave;o v\u0026agrave; sử dụng để truy cập v\u0026agrave;o APIs hoặc t\u0026agrave;i nguy\u0026ecirc;n ra sao\n1. ứng dụng hoặc request ph\u0026iacute;a m\u0026aacute;y kh\u0026aacute;ch gửi y\u0026ecirc;u cầu cho việc x\u0026aacute;c thực sẽ được gửi đến server để ủy quyền, điều n\u0026agrave;y được thực hiện th\u0026ocirc;ng qua một trong những d\u0026ograve;ng ủy quyền kh\u0026aacute;c nhau, v\u0026iacute; dụ : một ứng dụng web tu\u0026acirc;n thủ OpenID Connect điển h\u0026igrave;nh sẽ đi qua /oauth/authorize endpoint sử dụng luồng m\u0026atilde; ủy quyền\n2. khi ủy quyền được cấp, m\u0026aacute;y chủ ủy quyền sẽ trả lại m\u0026atilde; th\u0026ocirc;ng b\u0026aacute;o truy cập cho ứng dụng\n3. ứng dụng sử dụng access token để truy cập v\u0026agrave;o t\u0026agrave;i nguy\u0026ecirc;n cần c\u0026oacute; quyền mới truy cập được (v\u0026iacute; dụ như một API)\nVới token đ\u0026atilde; được k\u0026iacute;, tất cả th\u0026ocirc;ng tin c\u0026oacute; trong token sẽ được hiển thị cho người d\u0026ugrave;ng hoặc c\u0026aacute;c b\u0026ecirc;n kh\u0026aacute;c, ngay cả khi họ kh\u0026ocirc;ng thể thay đổi th\u0026ocirc;ng tin đ\u0026oacute;. Điều n\u0026agrave;y nghĩa l\u0026agrave; bạn kh\u0026ocirc;ng n\u0026ecirc;n để th\u0026ocirc;ng tin b\u0026iacute; mật b\u0026ecirc;n trong token\nTại sao ch\u0026uacute;ng ta n\u0026ecirc;n sử dụng JSON Web Token ?  T\u0026aacute;c dụng của JWT so với SWT (simple web tokens) v\u0026agrave; SAML (security assertion markup language token)\nJSON ngắn gọn hơn XML n\u0026ecirc;n khi được m\u0026atilde; h\u0026oacute;a, k\u0026iacute;ch cỡ của n\u0026oacute; cũng nhỏ gọn hơn, thế n\u0026ecirc;n JSON sẽ nhỏ gọn hơn SAML. Đ\u0026acirc;y l\u0026agrave; một điểm cộng cho JWT khi truyền n\u0026oacute; v\u0026agrave;o HTML v\u0026agrave; m\u0026ocirc;i trường HTTP\nVề mặt bảo mật, SWT chỉ c\u0026oacute; thể được k\u0026yacute; đối xứng bằng một secret sử dụng thuật to\u0026aacute;n HMAC. Thế nhưng JWT v\u0026agrave; SAML token c\u0026oacute; thể sử dụng cặp public/private key dưới dạng chứng chỉ X.509 để k\u0026iacute;. Việc k\u0026iacute; XML với chữ k\u0026iacute; kĩ thuật XML m\u0026agrave; kh\u0026ocirc;ng tạo ra c\u0026aacute;c lỗ hổng bảo mật phức tạp hơn khi so s\u0026aacute;nh\u0026nbsp; việc k\u0026yacute; JSON.\u0026nbsp;\nJSON parsers v\u0026ocirc; c\u0026ugrave;ng phổ biến trong hầu hết c\u0026aacute;c ng\u0026ocirc;n ngữ lập tr\u0026igrave;nh bởi v\u0026igrave; n\u0026oacute; \u0026aacute;nh xạ trực tiếp đến đối tượng. Ngược lại, XML kh\u0026ocirc;ng c\u0026oacute; phương thức n\u0026agrave;o để l\u0026agrave;m điều n\u0026agrave;y một c\u0026aacute;ch tự nhi\u0026ecirc;n. Thế n\u0026ecirc;n JWT sẽ dễ d\u0026agrave;ng l\u0026agrave;m việc hơn so với SAML\u0026nbsp;\nVề c\u0026aacute;c sử dụng: JWT được sử dụng ở quy m\u0026ocirc; internet, l\u0026agrave;m nổi bật sự dễ d\u0026agrave;ng trong việc xử l\u0026iacute; ph\u0026iacute;a m\u0026aacute;y kh\u0026aacute;ch của JWT tr\u0026ecirc;n nhiều nền tảng, đặc biệt l\u0026agrave; tr\u0026ecirc;n thiết bị di động\u0026nbsp;\n","link":"https://vuduynhien.com/post/backend/posts/jwt-la-gi/","section":"post","tags":["authorization","lập trình web"],"title":"cùng tìm hiểu về JSON Web Token"},{"body":"","link":"https://vuduynhien.com/post/javascript/","section":"post","tags":null,"title":""},{"body":"","link":"https://vuduynhien.com/tags/javascript/","section":"tags","tags":null,"title":"javascript"},{"body":"","link":"https://vuduynhien.com/series/javascript/","section":"series","tags":null,"title":"javascript"},{"body":"A mircrotask queue is a queue of tasks that are executed after the current task. The microtas queue is handled by the JavaScript engine before it moves on to the next task in the callback queue\nconsole.log('start');\nsetTimeout(function() { console.log('setTimeout'); }, 0); Promise.resolve().then(function() { console.log('promise resolve'); }); console.log('end');\nsetTimeout callback is added to the callback queue. The Promise.resolve is added to the microtask queue. The JS engine will first execute all tasks in the microtask queue before moving on to the call queue\nTherefore, the output of the code above would be start\nend\npromise resolveset\nTimeout","link":"https://vuduynhien.com/post/javascript/posts/micro-task-queue/","section":"post","tags":["javascript"],"title":"mircotask queue là gì ?"},{"body":"the JavaScript Engine is a program whose main task is to read and execute JavaScript code. The way that this program works is:\n read the code translate it into machine code run that machine code   All modern browser come with their own version of the JS Engine but the most popular one is Google's V8 Engine.\u0026nbsp;\nHere is a list of different JavaScript Engines for each major internet browser:  V8: open source JavaScript Engine developed by Google for Chrome SpiderMonkey: the JavaScript Engine powering Mozilla FireFox JavaScriptCore: open source JavaScript Engine developed by Apple for Safari Rhino: open source JavaScript Engine managed by Mozilla foundation Chakra: a JavaScript Engnine for Microsoft Edge JerryScript: a JavaScript engine for the IOT  A JavaScript engine will always have: Call stack and Memory Heap\nThe Call Stack: keep track of where we are in the code. It uses first in and last out and stacks for example functions. Javascript code gets executed using something called as execution context\nThe Memory Heap: Heap is an unstructured memory pool which stores all the objects that a JavaScript application needs. Where memory is allocated, used, and removed\n\nHow does the JS Engnie work ?\nThe JavaScript Engine has 6 main components that work together as a whole. 1. Parser: the source code is sent to a decoder which decodes the contents inside HTML script tag into tokens that are sent to the parser. The engine tries to avoid parsing code that's not necessary right away in order to save time\n2. AST: the parser creates nodes based on the tokens it receives. With these nodes, it creates an Abstract Syntax Tree (AST)\n3. Interpreter: it generates byte code, by reading the code line by line Once the byte code is generated, the AST is deleted and memory space is cleared up.\n4. Profiler: Monitors and watches code to optimize it.\n5. Compiler: works ahead of time and creates a translation of the code that has been written and complies it down to a lower leverl language that machines can read\n6. Optimized code: code needs to be optimized to be run quicker. ","link":"https://vuduynhien.com/post/javascript/posts/js-engine/","section":"post","tags":["javascript"],"title":"Javascript engine là gì ?"},{"body":" A javascript runtime is an environment which provides all the necessary components \nComponents of JavaScript Runtime     JavaScript Engnine Web API\u0026nbsp;  Callback Queue Microtask Queue       In order to use and run a javascript program.\u0026nbsp; Js code may be executed in one of two runtime enviroments:   The runtime environment of a browser (like chrome or firefox)  The Node runtime environment.    \u0026nbsp;  where do js code is executed ?   how it works ?   A browser's runtime environment Applications created for and executed in the browser are known as front-end applications.\u0026nbsp; The browser environment has a lot of buil in methods such as window.alert(), window object provides access to a huge amount of data and functionality relatating to open browser window beyond just .alert()   the Node runtime environment Without a browser, to execute the JS code, you have to set up Node on your computer Node is an entirely different runtime environment, meaning that browser-environment data values and functions, like window.alert() can't be used. Instead, the Node runtime gives back-end applications access to a variety of features unavailable in a browser, such as access to the server's file system, database, and network    ","link":"https://vuduynhien.com/post/javascript/posts/js-runtime-la-gi/","section":"post","tags":["javascript"],"title":"Javascript runtime là gì ?"},{"body":"API stands for Application Programming Interface\nA WebAPI is an application programming interface for the Web\nA browser API can extend the functionality of a web browser\nA server API can extend the functionality of a web server\nAPI are constructs made avaible in programming languages to allow developers to create complex functionality more easily. They abstract more complex code away from you, providing some easier syntax to use in its place.\nProgram some 3D graphics, it is a lot easier to do it using an API writen in a higher-level language such as JavaScript or Python, rather than try to directly write low-level code that directly controls the computer's GPU or other graphics functions\nClient-side JavaScript has many APIs- these are not part of the JavaScript language itself, rather they are built on top on the core JavaScript language, providing you with extra superpowers to use in your JS code. JS simply gets access to these APIs through the global window object. For example: console.log is not actually a part of JS language itself. We can access to console.log because it is provided by WEB API. WEB API generally fall into two categories:\n Browser APIs: are built into web browser and are able to expose data from the browser and surrounding computer environment and do useful compex things with it. For example the Web Audio API provides JS constructs for manipulating audio in the browser - taking audio track, altering its volume, applying effects to it,... behind the scence, the browser is actually using some complex lower-level code (ex: C++, Rust) to do that actual audio processing, this complexity is abstracted away by the API Third-part APIs:\u0026nbsp;are not built into the browser by default, you generally have to retrieve their code and information from somewhere on the Web. For example: the Twitter API allows you to display your latest tweets on your website.\u0026nbsp; ","link":"https://vuduynhien.com/post/javascript/posts/web-api/","section":"post","tags":["javascript"],"title":"web api là gì ?"},{"body":"REDUX LÀ GÌ ? Redux là khuôn mẫu, là thư viện cho việc quản lí, cập nhật các state trong web app thông qua việc sử dụng các sự kiện hay còn được gọi là \u0026quot;actions\u0026quot;. Redux giúp tập trung hóa trong việc lưu trữ các state mà được sử dụng xuyên suốt toàn bộ web app, state chỉ thay đổi trong 1 hành vi chủ ý, có thể dự đoán được điều gì sẽ xảy ra và xảy ra như thế nào với các state.\nTại sao tau nên sử dụng redux ? Việc sử dụng redux sẽ giúp cho người lập trình viên dễ dàng hơn trong việc hiểu khi nào, ở đâu, tại sao và làm thế nào các state ở trong web app được cập nhật và web app logic như thế nào khi thực hiện 1 hành vi. Bạn sẽ lên kịch bản cho web app hoạt động theo đúng mong đợi.\nKhi nào thì tau nên sử dụng redux ? Giống như các tool khác, Redux thì không hoàn hảo và ưu việt 100%, không phải app nào cũng cần đến redux. Nó phải đánh đổi cả đấy anh bạn già à. Nào là có nhiều khái niệm phải học, nhiều code hơn phải viết. Nó thêm vài cái hơi hơi khó hiểu trong code của bạn,... redux sẽ phù hợp nếu như bạn gặp phải các trường hợp sau\n bạn có một lượng lớn state mà cần được sử dụng ở nhiều nơi trong ứng dụng các state cập nhật thường xuyên logic để cập nhật state phức tạp như bạn gái bạn web app có lượng lớn code, làm việc cùng với nhiều người  function Counter() { // State: a counter value const [counter, setCounter] = useState(0) // Action: code that causes an update to the state when something happens const increment = () =\u0026gt; { setCounter(prevCounter =\u0026gt; prevCounter + 1) } // View: the UI definition return ( \u0026lt;div\u0026gt; Value: {counter} \u0026lt;button onClick={increment}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) }  state: gọi là state đi trong trường hợp code bên trên thì state là counter á\nview: phần UI để render dựa trên stat hiện tại í, trong trường hợp trên thì nó là cái thẻ \nactions: cái sự kiện sẽ xảy ra nếu bạn ấn vào cái button có onCLick bên trên kia kìa.\nví dụ trên gọi là one-way data flow\n  state: tại một thời điểm cụ thể state đang mang giá trị nào (state là trạng thái á bạn)\n  view: giao diện sẽ được render dựa vào state thời điểm ban đầu\n  actions: khi điều gì đó xảy ra (như việc bạn bấm vào cái nút), state sẽ được cập nhật trạng thái mới tùy theo logic do người lập trình viết ra\n  view: giao diện sẽ được render lại dựa trên state mới\n      Weo trông khá chi là cơ bản, đơn giản con gián, thế nhưng cái sự đơn giản tình cảm này sẽ bị thao túng tâm lí rồi trở nên phức tạp khi anh bạn có rất nhiều components cần sử dụng cùng chung state, các component này lại nằm ở những phần khác nhau trong web app. Từ đó có cách giải quyết vấn đề này gọi là lifting state up (tra google ha).\nMột cách nữa để giải quyết vấn đề này đó là ép các state được chia sẻ từ component, rồi đặt nó vào trong khu vực tập trung state bên ngoài component cây. Với điều này component của chúng ta sẽ trở thành 1 cái view lớn, và bất kì component nào cũng có thể truy cập vào state hoặc actions, dù nó ở bất cứ đâu đi chăng nữa\nbằng cách định nghĩa và tách các khái niệm liên quan đến việc quản lí các state và thi hành nhưng luật mà duy trì các giữa view và state, chúng tao sẽ gửi cho m xem đoạn code phía dưới và sự duy trì của nó\nbây là ý tưởng cơ bản đằng sau redux, 1 cái loz què tập trung các state ở global state,\nImmnutability\nMutable nghĩa là có thể thay đổi, nếu cái quần gì immutable, tức là nó không bao giờ thay đổi\nobject trong javascript và array là có thể thay đổi. Nếu bạn tạo 1 object, thì mình có thể thay đổi nội dung bên trong fields của nó. Nếu bạn tạo array, bạn có thể thay đổi nội dung của nó mà.\nNhư vậy gọi là mutating. Là do array hoặc object nó tham chiếu đến địa chỉ ô nhớ, địa chỉ ô nhớ coi như là cái hộp, bên trong cái hộp chưa nội dung, khi bạn thay đổi nội dung bên trong cái hộp thì những cái tham chiếu đến cái hộp thay đổi theo là đúng rồi\nĐể mà update giá trị không thể thay đổi, code của bạn sẽ phải copy cái array hoặc object đó sau đó thay đổi nó.\nChúng ta sẽ làm điều này bằng tay bằng việc sử dụng array hoặc object spread operator,\nRedux được mong đợi là sẽ update các state qua việc không thể thay đổi\nTHUẬT NGỮ\nCó vài thuật ngữ quan trọng của redux mà bạn sẽ cần phải làm quen trước khi tiếp tục\n actions: một action là 1 object javascript có filed type. Bạn có thể coi một action tức là một sự kiện mô tả điều gì đó sẽ xảy ra trong ứng dụng. field type có thể là một string mô tả tên hành động như \u0026quot;todo/todoAdded\u0026quot;. Lập trình viên thường viế các type như \u0026quot;domain/eventName\u0026quot; nơi mà phần đầu tiên của tính năng hay danh mục mà action ấy thuộc về. và phần thứ 2 là xác định điều gì sẽ xảy ra  Một đối tượng action có thể có các filed khác với các thông tin đính kèm về điều gì sẽ xảy ra. THeo quy ước thì lập trình viên sẽ để thông tin trong 1 filed gọi là payload\nmột object actoin thường trông như sau:\nconst addTodoAction = { type: 'todos/todoAdded', payload: 'Buy milk' }  actions creators\nmột action creator là một hàm mà tạo ra và trả về 1 action object. Lập trình viên thường sử dụng những cái này do vậy họ không phải viết các đối tượng action bằng tay mỗi khi\nconst addTodo = text =\u0026gt; { return { type: 'todos/todoAdded', payload: text } }  Reducers\nmột reducer là một hàm mà nhận state hiện tại và một đối tượng action. quyết định làm thế nào để cập nhật các state khi cần thiết và trả về state mới. (state, action) =\u0026gt; newState. Bạn có thể nghĩ reducer như một event listener - sẽ xử lí các sự kiện dựa trên các action được nhận vào\nÊ chú ý là: reducer functions sẽ nhận tên cuả nó bởi vì nó giống giống với một loại callback function bạn pass qua phương thức: Array.reduce()\nreducers phải tuân theo các quy luật sau:\n  nó nên chỉ tính các state mới dựa trên state và tham số action\n  nó không cho phép chỉnh sửa state đang tồn tại. Thay vào đó nó sẽ cập nhật các giá trị không thể thay đổi bằng cách copy state hiện tại sau đó thay đổi phiên bản copy\n  nó phải không làm bất cứ cái gì bất đồng bộ, tính toán giá trị ngẫu nhiên, hoặc side effects\n  chúng ta sẽ nói nhiều hơn về các quy luật của reducer sau. bao gồm tại sao nó quan trọng và làm sao để thi hành reducer đúng cách\nLogic bên trong hàm reducer thường theo các bước sau:\n  kiểm tra xem reducer có hành động không, nếu có làm 1 bản copy các state, update bản copy với giá trị mới rồi trả về nó\n  nếu không trả về giá trị state hiện tại khi chưa đc thay đổi\n  Đây là một ví dụ nhỏ về reducer, thể hiện các bước mà mỗi reducer nên tuân theo\nconst initialState = { value: 0 } function counterReducer(state = initialState, action) { // Check to see if the reducer cares about this action if (action.type === 'counter/increment') { // If so, make a copy of `state` return { ...state, // and update the copy with the new value value: state.value + 1 } } // otherwise return the existing state unchanged return state }  Tại sao gọi là reducer ... xem google\nstore\ndispatch\nredux app structure - cấu trúc ứng dụng redux Redux store được tạo bằng cách dùng hàm configureStore từ redux toolkit, configure store yêu cầu chúng ta truyền đối số reducer\nứng dụng của chúng ta có thể được tạo ra bởi nhiều tính năng, và mỗi tính năng có hàm xử lí riêng. Khi chúng ta gọi hàm configureStore , chúng ta có thể truyền tất cả reducer vào trong một object. Key name ở trong object sẽ định nghĩa bên trong giá trị state\nfile name features/counter/counterSlice.js\n","link":"https://vuduynhien.com/post/pweb/react_js/redux/","section":"post","tags":["Lập trình web"],"title":"Hướng dẫn về redux và redux toolkit."},{"body":" Đôi khi bạn muốn state của 2 component cùng thay đổi. Để làm điều này, thì xóa state từ 2 component đó đi, sau đó chuyển cái state sang component cha gần nhất giữa 2 component, rồi pass state thông qua props. điều này gọi là lifting state up đó anh bạn, đây là sẽ điều bạn sẽ chơi thường xuyên khi code react js          import { useState } from 'react'; function Panel({ title, children }) { const [isActive, setIsActive] = useState(false); return ( \u0026lt;section className=\u0026quot;panel\u0026quot;\u0026gt; \u0026lt;h3\u0026gt;{title}\u0026lt;/h3\u0026gt; {isActive ? ( \u0026lt;p\u0026gt;{children}\u0026lt;/p\u0026gt; ) : ( \u0026lt;button onClick={() =\u0026gt; setIsActive(true)}\u0026gt; Show \u0026lt;/button\u0026gt; )} \u0026lt;/section\u0026gt; ); } export default function Accordion() { return ( \u0026lt;\u0026gt; \u0026lt;h2\u0026gt;Almaty, Kazakhstan\u0026lt;/h2\u0026gt; \u0026lt;Panel title=\u0026quot;About\u0026quot;\u0026gt; With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city. \u0026lt;/Panel\u0026gt; \u0026lt;Panel title=\u0026quot;Etymology\u0026quot;\u0026gt; The name comes from \u0026lt;span lang=\u0026quot;kk-KZ\u0026quot;\u0026gt;алма\u0026lt;/span\u0026gt;, the Kazakh word for \u0026quot;apple\u0026quot; and is often translated as \u0026quot;full of apples\u0026quot;. In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild \u0026lt;i lang=\u0026quot;la\u0026quot;\u0026gt;Malus sieversii\u0026lt;/i\u0026gt; is considered a likely candidate for the ancestor of the modern domestic apple. \u0026lt;/Panel\u0026gt; \u0026lt;/\u0026gt; ); }  Nhưng bây giờ hãy nói rằng bạn muốn thay đổi nó, chỉ mỗi panel được mở rộng trong 1 khoảng thời gian. Với kiểu thiết kế như trên thì việc mở rộng cái thứ 2 sẽ mở rộng luôn cái thứ nhất\nđể điều phối 2 panel này, bạn cần lift their state up hay còn gọi là nâng state lên parent component qua 3 bước sau:\n  xóa staet từ component con\n  pass hardcode từ component cha\n  thêm state vào component cha và pass nó xuống với các event\n  điều này sẽ cho phép component Accordion tương đương với cả 2 component Panel và chỉ mở rộng trong 1 khoảng thời gian\n        \u0026quot;Vô link này xem ví dụ giải thích mệt quá, tra google đọc docs đi cho lẹ\u0026quot;\nMột vài sự thật thú vị về mỗi state\n\u0026quot;Dịch hơi chán đọc kĩ link sau\u0026quot;\nkeyword single source of truth\n","link":"https://vuduynhien.com/post/pweb/react_js/lifting_state_up/","section":"post","tags":["Lập trình web"],"title":"Lifting state up"},{"body":"","link":"https://vuduynhien.com/series/react-js/","section":"series","tags":null,"title":"React js"},{"body":"","link":"https://vuduynhien.com/tags/c-c%C6%A1-b%E1%BA%A3n/","section":"tags","tags":null,"title":"C cơ bản"},{"body":"","link":"https://vuduynhien.com/categories/c-c%C6%A1-b%E1%BA%A3n/","section":"categories","tags":null,"title":"C cơ bản"},{"body":"","link":"https://vuduynhien.com/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"cùng mình tìm hiểu về 2 khái niệm này nha.\n1. Logical Operators Hay còn được gọi với cái tên toán tử logic. Lưu ý: trong C hay hầu hết các ngôn ngữ lập trình khác thì bất kể biểu thức nào có kết quả khác 0 sẽ được convert thành true, ngược lại biểu thức nào có kết quả là 0 sẽ được convert thành false. Đọc nhẩm câu này rồi hãng đọc xuống phía dưới nhé.\nI. Toán tử \u0026amp;\u0026amp;\nHay còn gọi là \u0026quot;và\u0026quot;, toán tử \u0026amp;\u0026amp; sẽ kiểm tra nếu cả 2 biểu thức đều có kết quả là true sẽ trả về true. Còn nếu biểu thức thứ nhất là false thì biểu thức thứ 2 sẽ không được kiểm tra nữa. Hiểu đơn giản là toán tử \u0026amp;\u0026amp; sẽ kiểm tra từ trái sang phải, nếu nó phát hiện biểu thức nào sai sẽ trả về false luôn, còn nếu chạy từ đầu đến cuối không phát hiện cái nào sai thì biểu thức trả về true\nif ((5 == 5) \u0026amp;\u0026amp; (7 == 10 \u0026amp;\u0026amp; 6 == 6)) printf(\u0026quot;sai rui bro\u0026quot;) \nII. Toán tử ||\nHay còn gọi là \u0026quot;hoặc\u0026quot;, toán tử || sẽ kiểm tra nếu ít nhất một trong 2 biểu thức có kết quả là true thì sẽ trả về true. Nếu biểu thức đầu tiên là true thì sẽ trả về true luôn khỏi kiểm tra nữa. Hiểu đơn giản là toán tử || sẽ kiểm tra từ trái qua phải, nếu nó phát hiện biểu thức nào true thì trả về true luôn, khỏi kiểm tra các thằng tiếp theo, còn nếu chạy từ đầu đến cuối không phát hiện ra thằng nào true cả thì biểu thức trả về false.\nif ((4 == 5 || 2 == 4 || 6 == 6 || 1 == 2)) printf(\u0026quot;oki dung nha nguoi ae\u0026quot;)\nNOTE: bạn có thể thêm ! đằng trước biểu thức để tìm giá trị đối lập\nif (! (4 == 5)) sẽ trả về true, vì 4 == 5 là false nhưng ! đã trả về kết quả trái ngược false là true. Sau khi biết kiến thức này bạn có thể nói với bạn gái của bạn là: ! (em là cô gái xinh đẹp nhất trên cái cuộc đời này).\nBởi vì sau khi nhận được kết quả trả về, biểu thức logical sẽ không xét các biểu thức phía bên phải biểu thức đúng thế nên nếu có ý định thực hiện điều gì bạn nên viết ra bên ngoài của biểu thức logic\nif (0 \u0026amp;\u0026amp; x++) bar() hàm bar() sẽ không được gọi và x cũng sẽ không được tăng lên, nếu mà bạn có ý định tăng giá trị của x lên thì nên viết ra bên ngoài của biểu thức logical\nif (1 \u0026amp;\u0026amp; x++) bar() hàm bar() sẽ được gọi và x cũng sẽ được tăng lên.\nif (1 \u0026amp;\u0026amp; x++ \u0026amp;\u0026amp; 1 == 3) bar() hàm bar() sẽ không được gọi do kết quả của biểu thức logic trả về false, nhưng x vẫn được tăng lên 1 giá trị do biểu thức đã thực thi xong x++ mới thực thi đến biểu thức sai. \\\n2 BITWISE Logical Operators Hay còn gọi là phép toán thao tác bit.\nBit là các chữ số mang trạng thái tắt hoặc mở hay 0 và 1 trong máy tính. Khi các chữ số này được kết hợp với nhau sẽ ra 1 dãy nhị phân. Các bạn tìm hiểu về cách chuyển đổi giữa các hệ trong máy tính nha, cái này hồi cấp 2, thpt có học rồi á.\nVí dụ A = 0B10111001. thì chuyển sang thập phân sẽ là 2 ^ 7 * 1 + 2 ^ 6 * 0 + 2 ^ 5 * 1 + 2 ^ 4 * 1 + 2 ^ 3 * 1 * 2 ^ 2 * 0 + 2 ^ 1 * 0 + 2 ^ 0 *1 = 185 :))) nhìn dài quá có thể mình viết nhầm cơ mà ý là các bạn xếp các chữ số 0 và 1 thành 1 hàng rồi đánh số thức tự giảm dần cho đến 0. Sau đó thực hiện cộng các phép toán là 2 ^ (vị trí của chữ số 0 hoặc 1) * (chữ số 0 hoặc 1)\nI. Phép toán \u0026amp;\nHay còn gọi là AND\n0 and 0 = 0\n1 and 0 = 0\n0 and 1 = 0\n1 and 1 = 1\nNgồi suy luận đi ha. :)) thôi giải thích cho: khi cả 2 bit đều là 1 thì là 1 còn lại 0, nói kiểu bình thường thì là nếu cả 2 điều kiện cùng đúng thì nó đúng và còn lại là sai.\nví dụ 11001001 \u0026amp; 10011011 = 10001001\nII. Phép toán |\nHay còn gọi là OR\n0 | 0 = 0\n1 | 0 = 1\n0 | 1 = 1\n1 | 1 = 1\nkhi cả 2 bit đều là 0 thì là 0 còn lại là 1, nói kiểu nỏmie là khi chỉ cần ít nhất 1 điều kiện là 1 thì biểu thức đúng\nví dụ 1 0 1 1 0 0 1 | 0 0 1 1 0 0 1 1 = 1 0 1 1 1 0 0 1 1\nIII. Phép toán ^\nHay còn gọi là XOR\n0 ^ 0 = 0\n1 ^ 1 = 0\n0 ^ 1 = 1\n1 ^ 0 = 1\nNếu cả 2 bit khác nhau sẽ cho ra kết quả là 1, ngược lại cả 2 bit giống nhau sẽ cho ra kết quả 0. Từ đó ta thấy nếu A XOR B = 0 thì A == B. Nói kiểu bình thường: nếu 2 điều kiện mang giá trị đúng - sai khác nhau thì kết quả trả về đúng.\nIV. Phép toán ~\nHay còn gọi là phép toán NOT\ntức là\n~ 0 = 1\n~ 1 = 0\n~11001001 = 00110110\n=\u0026gt; Như vậy sau khi đọc hết bài viết bạn có thể nhận ra là bitwise operators để thao tác bit còn logical operator là phép toán thao tác giữa các biểu thức.\n","link":"https://vuduynhien.com/post/pbasic/cbs/posts/logicalexpression/","section":"post","tags":["C cơ bản"],"title":"Logical Operators và Bitwise Logical Operators là gì ? chúng khác như thế nào ? "},{"body":"","link":"https://vuduynhien.com/series/l%E1%BA%ADp-tr%C3%ACnh-c/","section":"series","tags":null,"title":"Lập trình C"},{"body":"","link":"https://vuduynhien.com/categories/n%E1%BB%81n-t%E1%BA%A3ng/","section":"categories","tags":null,"title":"Nền tảng"},{"body":"Vũ Duy Nhiên là một sinh viên.\n","link":"https://vuduynhien.com/about/","section":"","tags":null,"title":"Về Vũ Duy Nhiên"},{"body":"","link":"https://vuduynhien.com/post/frontend/","section":"post","tags":null,"title":""},{"body":"","link":"https://vuduynhien.com/post/pbasic/cbs/","section":"post","tags":null,"title":""},{"body":"","link":"https://vuduynhien.com/post/pbasic/jvbs/","section":"post","tags":null,"title":""},{"body":"","link":"https://vuduynhien.com/post/pweb/react_js/","section":"post","tags":null,"title":""}]