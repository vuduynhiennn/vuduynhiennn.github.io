[{"body":"","link":"https://vuduynhien.com/","section":"","tags":null,"title":""},{"body":"","link":"https://vuduynhien.com/post/pweb/","section":"post","tags":null,"title":""},{"body":"REDUX LÀ GÌ ? Redux là khuôn mẫu, là thư viện cho việc quản lí, cập nhật các state trong web app thông qua việc sử dụng các sự kiện hay còn được gọi là \u0026quot;actions\u0026quot;. Redux giúp tập trung hóa trong việc lưu trữ các state mà được sử dụng xuyên suốt toàn bộ web app, state chỉ thay đổi trong 1 hành vi chủ ý, có thể dự đoán được điều gì sẽ xảy ra và xảy ra như thế nào với các state.\nTại sao tau nên sử dụng redux ? Việc sử dụng redux sẽ giúp cho người lập trình viên dễ dàng hơn trong việc hiểu khi nào, ở đâu, tại sao và làm thế nào các state ở trong web app được cập nhật và web app logic như thế nào khi thực hiện 1 hành vi. Bạn sẽ lên kịch bản cho web app hoạt động theo đúng mong đợi.\nKhi nào thì tau nên sử dụng redux ? Giống như các tool khác, Redux thì không hoàn hảo và ưu việt 100%, không phải app nào cũng cần đến redux. Nó phải đánh đổi cả đấy anh bạn già à. Nào là có nhiều khái niệm phải học, nhiều code hơn phải viết. Nó thêm vài cái hơi hơi khó hiểu trong code của bạn,... redux sẽ phù hợp nếu như bạn gặp phải các trường hợp sau\n bạn có một lượng lớn state mà cần được sử dụng ở nhiều nơi trong ứng dụng các state cập nhật thường xuyên logic để cập nhật state phức tạp như bạn gái bạn web app có lượng lớn code, làm việc cùng với nhiều người  function Counter() { // State: a counter value const [counter, setCounter] = useState(0) // Action: code that causes an update to the state when something happens const increment = () =\u0026gt; { setCounter(prevCounter =\u0026gt; prevCounter + 1) } // View: the UI definition return ( \u0026lt;div\u0026gt; Value: {counter} \u0026lt;button onClick={increment}\u0026gt;Increment\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; ) }  state: gọi là state đi trong trường hợp code bên trên thì state là counter á\nview: phần UI để render dựa trên stat hiện tại í, trong trường hợp trên thì nó là cái thẻ \nactions: cái sự kiện sẽ xảy ra nếu bạn ấn vào cái button có onCLick bên trên kia kìa.\nví dụ trên gọi là one-way data flow\n  state: tại một thời điểm cụ thể state đang mang giá trị nào (state là trạng thái á bạn)\n  view: giao diện sẽ được render dựa vào state thời điểm ban đầu\n  actions: khi điều gì đó xảy ra (như việc bạn bấm vào cái nút), state sẽ được cập nhật trạng thái mới tùy theo logic do người lập trình viết ra\n  view: giao diện sẽ được render lại dựa trên state mới\n      Weo trông khá chi là cơ bản, đơn giản con gián, thế nhưng cái sự đơn giản tình cảm này sẽ bị thao túng tâm lí rồi trở nên phức tạp khi anh bạn có rất nhiều components cần sử dụng cùng chung state, các component này lại nằm ở những phần khác nhau trong web app. Từ đó có cách giải quyết vấn đề này gọi là lifting state up (tra google ha).\nMột cách nữa để giải quyết vấn đề này đó là ép các state được chia sẻ từ component, rồi đặt nó vào trong khu vực tập trung state bên ngoài component cây. Với điều này component của chúng ta sẽ trở thành 1 cái view lớn, và bất kì component nào cũng có thể truy cập vào state hoặc actions, dù nó ở bất cứ đâu đi chăng nữa\nbằng cách định nghĩa và tách các khái niệm liên quan đến việc quản lí các state và thi hành nhưng luật mà duy trì các giữa view và state, chúng tao sẽ gửi cho m xem đoạn code phía dưới và sự duy trì của nó\nbây là ý tưởng cơ bản đằng sau redux, 1 cái loz què tập trung các state ở global state,\nImmnutability\nMutable nghĩa là có thể thay đổi, nếu cái quần gì immutable, tức là nó không bao giờ thay đổi\nobject trong javascript và array là có thể thay đổi. Nếu bạn tạo 1 object, thì mình có thể thay đổi nội dung bên trong fields của nó. Nếu bạn tạo array, bạn có thể thay đổi nội dung của nó mà.\nNhư vậy gọi là mutating. Là do array hoặc object nó tham chiếu đến địa chỉ ô nhớ, địa chỉ ô nhớ coi như là cái hộp, bên trong cái hộp chưa nội dung, khi bạn thay đổi nội dung bên trong cái hộp thì những cái tham chiếu đến cái hộp thay đổi theo là đúng rồi\nĐể mà update giá trị không thể thay đổi, code của bạn sẽ phải copy cái array hoặc object đó sau đó thay đổi nó.\nChúng ta sẽ làm điều này bằng tay bằng việc sử dụng array hoặc object spread operator,\nRedux được mong đợi là sẽ update các state qua việc không thể thay đổi\nTHUẬT NGỮ\nCó vài thuật ngữ quan trọng của redux mà bạn sẽ cần phải làm quen trước khi tiếp tục\n actions: một action là 1 object javascript có filed type. Bạn có thể coi một action tức là một sự kiện mô tả điều gì đó sẽ xảy ra trong ứng dụng. field type có thể là một string mô tả tên hành động như \u0026quot;todo/todoAdded\u0026quot;. Lập trình viên thường viế các type như \u0026quot;domain/eventName\u0026quot; nơi mà phần đầu tiên của tính năng hay danh mục mà action ấy thuộc về. và phần thứ 2 là xác định điều gì sẽ xảy ra  Một đối tượng action có thể có các filed khác với các thông tin đính kèm về điều gì sẽ xảy ra. THeo quy ước thì lập trình viên sẽ để thông tin trong 1 filed gọi là payload\nmột object actoin thường trông như sau:\nconst addTodoAction = { type: 'todos/todoAdded', payload: 'Buy milk' }  actions creators\nmột action creator là một hàm mà tạo ra và trả về 1 action object. Lập trình viên thường sử dụng những cái này do vậy họ không phải viết các đối tượng action bằng tay mỗi khi\nconst addTodo = text =\u0026gt; { return { type: 'todos/todoAdded', payload: text } }  Reducers\nmột reducer là một hàm mà nhận state hiện tại và một đối tượng action. quyết định làm thế nào để cập nhật các state khi cần thiết và trả về state mới. (state, action) =\u0026gt; newState. Bạn có thể nghĩ reducer như một event listener - sẽ xử lí các sự kiện dựa trên các action được nhận vào\nÊ chú ý là: reducer functions sẽ nhận tên cuả nó bởi vì nó giống giống với một loại callback function bạn pass qua phương thức: Array.reduce()\nreducers phải tuân theo các quy luật sau:\n  nó nên chỉ tính các state mới dựa trên state và tham số action\n  nó không cho phép chỉnh sửa state đang tồn tại. Thay vào đó nó sẽ cập nhật các giá trị không thể thay đổi bằng cách copy state hiện tại sau đó thay đổi phiên bản copy\n  nó phải không làm bất cứ cái gì bất đồng bộ, tính toán giá trị ngẫu nhiên, hoặc side effects\n  chúng ta sẽ nói nhiều hơn về các quy luật của reducer sau. bao gồm tại sao nó quan trọng và làm sao để thi hành reducer đúng cách\nLogic bên trong hàm reducer thường theo các bước sau:\n  kiểm tra xem reducer có hành động không, nếu có làm 1 bản copy các state, update bản copy với giá trị mới rồi trả về nó\n  nếu không trả về giá trị state hiện tại khi chưa đc thay đổi\n  Đây là một ví dụ nhỏ về reducer, thể hiện các bước mà mỗi reducer nên tuân theo\nconst initialState = { value: 0 } function counterReducer(state = initialState, action) { // Check to see if the reducer cares about this action if (action.type === 'counter/increment') { // If so, make a copy of `state` return { ...state, // and update the copy with the new value value: state.value + 1 } } // otherwise return the existing state unchanged return state }  Tại sao gọi là reducer ... xem google\nstore\ndispatch\n","link":"https://vuduynhien.com/post/pweb/react_js/redux/","section":"post","tags":["Lập trình web"],"title":"Hướng dẫn về redux và redux toolkit."},{"body":" Đôi khi bạn muốn state của 2 component cùng thay đổi. Để làm điều này, thì xóa state từ 2 component đó đi, sau đó chuyển cái state sang component cha gần nhất giữa 2 component, rồi pass state thông qua props. điều này gọi là lifting state up đó anh bạn, đây là sẽ điều bạn sẽ chơi thường xuyên khi code react js          import { useState } from 'react'; function Panel({ title, children }) { const [isActive, setIsActive] = useState(false); return ( \u0026lt;section className=\u0026quot;panel\u0026quot;\u0026gt; \u0026lt;h3\u0026gt;{title}\u0026lt;/h3\u0026gt; {isActive ? ( \u0026lt;p\u0026gt;{children}\u0026lt;/p\u0026gt; ) : ( \u0026lt;button onClick={() =\u0026gt; setIsActive(true)}\u0026gt; Show \u0026lt;/button\u0026gt; )} \u0026lt;/section\u0026gt; ); } export default function Accordion() { return ( \u0026lt;\u0026gt; \u0026lt;h2\u0026gt;Almaty, Kazakhstan\u0026lt;/h2\u0026gt; \u0026lt;Panel title=\u0026quot;About\u0026quot;\u0026gt; With a population of about 2 million, Almaty is Kazakhstan's largest city. From 1929 to 1997, it was its capital city. \u0026lt;/Panel\u0026gt; \u0026lt;Panel title=\u0026quot;Etymology\u0026quot;\u0026gt; The name comes from \u0026lt;span lang=\u0026quot;kk-KZ\u0026quot;\u0026gt;алма\u0026lt;/span\u0026gt;, the Kazakh word for \u0026quot;apple\u0026quot; and is often translated as \u0026quot;full of apples\u0026quot;. In fact, the region surrounding Almaty is thought to be the ancestral home of the apple, and the wild \u0026lt;i lang=\u0026quot;la\u0026quot;\u0026gt;Malus sieversii\u0026lt;/i\u0026gt; is considered a likely candidate for the ancestor of the modern domestic apple. \u0026lt;/Panel\u0026gt; \u0026lt;/\u0026gt; ); }  Nhưng bây giờ hãy nói rằng bạn muốn thay đổi nó, chỉ mỗi panel được mở rộng trong 1 khoảng thời gian. Với kiểu thiết kế như trên thì việc mở rộng cái thứ 2 sẽ mở rộng luôn cái thứ nhất\nđể điều phối 2 panel này, bạn cần lift their state up hay còn gọi là nâng state lên parent component qua 3 bước sau:\n  xóa staet từ component con\n  pass hardcode từ component cha\n  thêm state vào component cha và pass nó xuống với các event\n  điều này sẽ cho phép component Accordion tương đương với cả 2 component Panel và chỉ mở rộng trong 1 khoảng thời gian\n        \u0026quot;Vô link này xem ví dụ giải thích mệt quá, tra google đọc docs đi cho lẹ\u0026quot;\nMột vài sự thật thú vị về mỗi state\n\u0026quot;Dịch hơi chán đọc kĩ link sau\u0026quot;\nkeyword single source of truth\n","link":"https://vuduynhien.com/post/pweb/react_js/lifting_state_up/","section":"post","tags":["Lập trình web"],"title":"Lifting state up"},{"body":"","link":"https://vuduynhien.com/tags/l%E1%BA%ADp-tr%C3%ACnh-web/","section":"tags","tags":null,"title":"Lập trình web"},{"body":"","link":"https://vuduynhien.com/post/","section":"post","tags":null,"title":"Posts"},{"body":"","link":"https://vuduynhien.com/series/react-js/","section":"series","tags":null,"title":"React js"},{"body":"","link":"https://vuduynhien.com/series/","section":"series","tags":null,"title":"Series"},{"body":"","link":"https://vuduynhien.com/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://vuduynhien.com/tags/c-c%C6%A1-b%E1%BA%A3n/","section":"tags","tags":null,"title":"C cơ bản"},{"body":"","link":"https://vuduynhien.com/categories/c-c%C6%A1-b%E1%BA%A3n/","section":"categories","tags":null,"title":"C cơ bản"},{"body":"","link":"https://vuduynhien.com/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"cùng mình tìm hiểu về 2 khái niệm này nha.\n1. Logical Operators Hay còn được gọi với cái tên toán tử logic. Lưu ý: trong C hay hầu hết các ngôn ngữ lập trình khác thì bất kể biểu thức nào có kết quả khác 0 sẽ được convert thành true, ngược lại biểu thức nào có kết quả là 0 sẽ được convert thành false. Đọc nhẩm câu này rồi hãng đọc xuống phía dưới nhé.\nI. Toán tử \u0026amp;\u0026amp;\nHay còn gọi là \u0026quot;và\u0026quot;, toán tử \u0026amp;\u0026amp; sẽ kiểm tra nếu cả 2 biểu thức đều có kết quả là true sẽ trả về true. Còn nếu biểu thức thứ nhất là false thì biểu thức thứ 2 sẽ không được kiểm tra nữa. Hiểu đơn giản là toán tử \u0026amp;\u0026amp; sẽ kiểm tra từ trái sang phải, nếu nó phát hiện biểu thức nào sai sẽ trả về false luôn, còn nếu chạy từ đầu đến cuối không phát hiện cái nào sai thì biểu thức trả về true\nif ((5 == 5) \u0026amp;\u0026amp; (7 == 10 \u0026amp;\u0026amp; 6 == 6)) printf(\u0026quot;sai rui bro\u0026quot;) \nII. Toán tử ||\nHay còn gọi là \u0026quot;hoặc\u0026quot;, toán tử || sẽ kiểm tra nếu ít nhất một trong 2 biểu thức có kết quả là true thì sẽ trả về true. Nếu biểu thức đầu tiên là true thì sẽ trả về true luôn khỏi kiểm tra nữa. Hiểu đơn giản là toán tử || sẽ kiểm tra từ trái qua phải, nếu nó phát hiện biểu thức nào true thì trả về true luôn, khỏi kiểm tra các thằng tiếp theo, còn nếu chạy từ đầu đến cuối không phát hiện ra thằng nào true cả thì biểu thức trả về false.\nif ((4 == 5 || 2 == 4 || 6 == 6 || 1 == 2)) printf(\u0026quot;oki dung nha nguoi ae\u0026quot;)\nNOTE: bạn có thể thêm ! đằng trước biểu thức để tìm giá trị đối lập\nif (! (4 == 5)) sẽ trả về true, vì 4 == 5 là false nhưng ! đã trả về kết quả trái ngược false là true. Sau khi biết kiến thức này bạn có thể nói với bạn gái của bạn là: ! (em là cô gái xinh đẹp nhất trên cái cuộc đời này).\nBởi vì sau khi nhận được kết quả trả về, biểu thức logical sẽ không xét các biểu thức phía bên phải biểu thức đúng thế nên nếu có ý định thực hiện điều gì bạn nên viết ra bên ngoài của biểu thức logic\nif (0 \u0026amp;\u0026amp; x++) bar() hàm bar() sẽ không được gọi và x cũng sẽ không được tăng lên, nếu mà bạn có ý định tăng giá trị của x lên thì nên viết ra bên ngoài của biểu thức logical\nif (1 \u0026amp;\u0026amp; x++) bar() hàm bar() sẽ được gọi và x cũng sẽ được tăng lên.\nif (1 \u0026amp;\u0026amp; x++ \u0026amp;\u0026amp; 1 == 3) bar() hàm bar() sẽ không được gọi do kết quả của biểu thức logic trả về false, nhưng x vẫn được tăng lên 1 giá trị do biểu thức đã thực thi xong x++ mới thực thi đến biểu thức sai. \\\n2 BITWISE Logical Operators Hay còn gọi là phép toán thao tác bit.\nBit là các chữ số mang trạng thái tắt hoặc mở hay 0 và 1 trong máy tính. Khi các chữ số này được kết hợp với nhau sẽ ra 1 dãy nhị phân. Các bạn tìm hiểu về cách chuyển đổi giữa các hệ trong máy tính nha, cái này hồi cấp 2, thpt có học rồi á.\nVí dụ A = 0B10111001. thì chuyển sang thập phân sẽ là 2 ^ 7 * 1 + 2 ^ 6 * 0 + 2 ^ 5 * 1 + 2 ^ 4 * 1 + 2 ^ 3 * 1 * 2 ^ 2 * 0 + 2 ^ 1 * 0 + 2 ^ 0 *1 = 185 :))) nhìn dài quá có thể mình viết nhầm cơ mà ý là các bạn xếp các chữ số 0 và 1 thành 1 hàng rồi đánh số thức tự giảm dần cho đến 0. Sau đó thực hiện cộng các phép toán là 2 ^ (vị trí của chữ số 0 hoặc 1) * (chữ số 0 hoặc 1)\nI. Phép toán \u0026amp;\nHay còn gọi là AND\n0 and 0 = 0\n1 and 0 = 0\n0 and 1 = 0\n1 and 1 = 1\nNgồi suy luận đi ha. :)) thôi giải thích cho: khi cả 2 bit đều là 1 thì là 1 còn lại 0, nói kiểu bình thường thì là nếu cả 2 điều kiện cùng đúng thì nó đúng và còn lại là sai.\nví dụ 11001001 \u0026amp; 10011011 = 10001001\nII. Phép toán |\nHay còn gọi là OR\n0 | 0 = 0\n1 | 0 = 1\n0 | 1 = 1\n1 | 1 = 1\nkhi cả 2 bit đều là 0 thì là 0 còn lại là 1, nói kiểu nỏmie là khi chỉ cần ít nhất 1 điều kiện là 1 thì biểu thức đúng\nví dụ 1 0 1 1 0 0 1 | 0 0 1 1 0 0 1 1 = 1 0 1 1 1 0 0 1 1\nIII. Phép toán ^\nHay còn gọi là XOR\n0 ^ 0 = 0\n1 ^ 1 = 0\n0 ^ 1 = 1\n1 ^ 0 = 1\nNếu cả 2 bit khác nhau sẽ cho ra kết quả là 1, ngược lại cả 2 bit giống nhau sẽ cho ra kết quả 0. Từ đó ta thấy nếu A XOR B = 0 thì A == B. Nói kiểu bình thường: nếu 2 điều kiện mang giá trị đúng - sai khác nhau thì kết quả trả về đúng.\nIV. Phép toán ~\nHay còn gọi là phép toán NOT\ntức là\n~ 0 = 1\n~ 1 = 0\n~11001001 = 00110110\n=\u0026gt; Như vậy sau khi đọc hết bài viết bạn có thể nhận ra là bitwise operators để thao tác bit còn logical operator là phép toán thao tác giữa các biểu thức.\n","link":"https://vuduynhien.com/post/pbasic/cbs/logicalexpression/","section":"post","tags":["C cơ bản"],"title":"Logical Operators và Bitwise Logical Operators là gì ? chúng khác như thế nào ? "},{"body":"","link":"https://vuduynhien.com/series/l%E1%BA%ADp-tr%C3%ACnh-c/","section":"series","tags":null,"title":"Lập trình C"},{"body":"","link":"https://vuduynhien.com/categories/n%E1%BB%81n-t%E1%BA%A3ng/","section":"categories","tags":null,"title":"Nền tảng"},{"body":"để ý đoạn nói về socket ha file description cả cái này nữa\n","link":"https://vuduynhien.com/post/pbasic/cbs/note/","section":"post","tags":["NOTE_C"],"title":"NOTE"},{"body":"","link":"https://vuduynhien.com/tags/note_c/","section":"tags","tags":null,"title":"NOTE_C"},{"body":"Vũ Duy Nhiên là một sinh viên.\n","link":"https://vuduynhien.com/about/","section":"","tags":null,"title":"Về Vũ Duy Nhiên"},{"body":"Vũ Duy Nhiên là một sinh viên.\n","link":"https://vuduynhien.com/about.vi/","section":"","tags":null,"title":"Về Vũ Duy Nhiên"},{"body":"","link":"https://vuduynhien.com/post/pbasic/cbs/","section":"post","tags":null,"title":""},{"body":"","link":"https://vuduynhien.com/post/pbasic/jvbs/","section":"post","tags":null,"title":""}]